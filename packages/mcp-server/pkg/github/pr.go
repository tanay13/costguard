package github

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/tanay13/costguard/packages/mcp-server/pkg/fix"
	"github.com/tanay13/costguard/packages/mcp-server/pkg/types"
)

type PRConfig struct {
	BaseBranch string
	RepoOwner  string
	RepoName   string
	Token      string
}

type PRResult struct {
	PRNumber   int    `json:"pr_number"`
	PRURL      string `json:"pr_url"`
	BranchName string `json:"branch_name"`
	Success    bool   `json:"success"`
	Error      string `json:"error,omitempty"`
}

func CreatePR(config PRConfig, actions []types.FixAction, decisionSummary types.AIDecisionSummary) (*PRResult, error) {

	branchName := fmt.Sprintf("costguard/optimize-%d", time.Now().Unix())

	if err := execGit("checkout", "-b", branchName); err != nil {
		return nil, fmt.Errorf("failed to create branch: %w", err)
	}

	for i, action := range actions {

		var decision *types.AIDecision
		for _, d := range decisionSummary.Decisions {
			if d.ActionID == fmt.Sprintf("action-%d", i) && d.Decision == "apply" {
				decision = &d
				break
			}
		}

		if decision == nil {
			continue
		}

		if err := fix.ApplyFix(action); err != nil {
			fmt.Printf("Warning: failed to apply fix for %s: %v\n", action.Resource, err)
			continue
		}
	}

	if err := execGit("add", "."); err != nil {
		return nil, fmt.Errorf("failed to stage changes: %w", err)
	}

	statusCmd := exec.Command("git", "status", "--porcelain")
	statusOut, _ := statusCmd.Output()
	if len(statusOut) == 0 {
		return nil, fmt.Errorf("no changes to commit")
	}

	commitMsg := buildCommitMessage(actions, decisionSummary)
	if err := execGit("commit", "-m", commitMsg); err != nil {
		return nil, fmt.Errorf("failed to commit: %w", err)
	}

	if err := execGit("push", "-u", "origin", branchName); err != nil {
		return nil, fmt.Errorf("failed to push branch: %w", err)
	}

	prTitle := buildPRTitle(decisionSummary)
	prBody := buildPRBody(actions, decisionSummary)

	prCmd := exec.Command(
		"gh", "pr", "create",
		"--title", prTitle,
		"--body", prBody,
		"--base", config.BaseBranch,
		"--head", branchName,
		"--json", "number,url",
	)

	var prOut bytes.Buffer
	var prErr bytes.Buffer
	prCmd.Stdout = &prOut
	prCmd.Stderr = &prErr

	err := prCmd.Run()

	if err != nil || strings.Contains(prErr.String(), "unknown flag: --json") {

		prCmd = exec.Command(
			"gh", "pr", "create",
			"--title", prTitle,
			"--body", prBody,
			"--base", config.BaseBranch,
			"--head", branchName,
		)

		prOut.Reset()
		prErr.Reset()
		prCmd.Stdout = &prOut
		prCmd.Stderr = &prErr

		if err := prCmd.Run(); err != nil {
			return nil, fmt.Errorf("failed to create PR: %w (stderr: %s)", err, prErr.String())
		}

		output := prOut.String()
		url := ""
		number := 0

		urlMatch := regexp.MustCompile(`https://github\.com/[^/]+/[^/]+/pull/\d+`).FindString(output)
		if urlMatch != "" {
			url = urlMatch

			numMatch := regexp.MustCompile(`/pull/(\d+)`).FindStringSubmatch(url)
			if len(numMatch) > 1 {
				fmt.Sscanf(numMatch[1], "%d", &number)
			}
		}

		if url == "" {

			remoteCmd := exec.Command("git", "remote", "get-url", "origin")
			remoteOut, _ := remoteCmd.Output()
			remoteURL := strings.TrimSpace(string(remoteOut))

			remoteURL = strings.Replace(remoteURL, "git@github.com:", "https://github.com/", 1)
			remoteURL = strings.TrimSuffix(remoteURL, ".git")
			url = remoteURL + fmt.Sprintf("/pull/%d", number)
		}

		return &PRResult{
			PRNumber:   number,
			PRURL:      url,
			BranchName: branchName,
			Success:    true,
		}, nil
	}

	var prData struct {
		Number int    `json:"number"`
		URL    string `json:"url"`
	}

	if err := json.Unmarshal(prOut.Bytes(), &prData); err != nil {

		output := prOut.String()
		urlMatch := regexp.MustCompile(`https://github\.com/[^/]+/[^/]+/pull/\d+`).FindString(output)
		if urlMatch != "" {
			prData.URL = urlMatch
			numMatch := regexp.MustCompile(`/pull/(\d+)`).FindStringSubmatch(urlMatch)
			if len(numMatch) > 1 {
				fmt.Sscanf(numMatch[1], "%d", &prData.Number)
			}
		} else {
			return nil, fmt.Errorf("failed to parse PR response: %w", err)
		}
	}

	return &PRResult{
		PRNumber:   prData.Number,
		PRURL:      prData.URL,
		BranchName: branchName,
		Success:    true,
	}, nil
}

func buildPRTitle(summary types.AIDecisionSummary) string {
	return fmt.Sprintf(
		"üí∞ CostGuard: Optimize resources (save $%.2f/month)",
		summary.TotalSavingsUSD,
	)
}

func buildPRBody(actions []types.FixAction, summary types.AIDecisionSummary) string {
	var body strings.Builder

	body.WriteString("## ü§ñ Automated Cost Optimization by CostGuard\n\n")
	body.WriteString("This PR was automatically generated by **CostGuard** with AI-driven decision-making.\n\n")

	body.WriteString("### üìä Summary\n\n")
	body.WriteString(fmt.Sprintf("- **Actions Applied:** %d\n", summary.ActionsToApply))
	body.WriteString(fmt.Sprintf("- **Estimated Monthly Savings:** $%.2f\n", summary.TotalSavingsUSD))
	body.WriteString(fmt.Sprintf("- **Risk Level:** Mixed (AI-reviewed)\n\n"))

	body.WriteString("### üîç AI Decision Summary\n\n")
	body.WriteString(fmt.Sprintf("```\n%s\n```\n\n", summary.Summary))

	body.WriteString("### üìù Changes\n\n")
	for i, action := range actions {
		var decision *types.AIDecision
		for _, d := range summary.Decisions {
			if d.ActionID == fmt.Sprintf("action-%d", i) {
				decision = &d
				break
			}
		}

		if decision != nil && decision.Decision == "apply" {
			body.WriteString(fmt.Sprintf("- **%s** (%s): %s\n", action.Resource, action.Intent, action.Description))
			body.WriteString(fmt.Sprintf("  - Savings: $%.2f/month\n", decision.EstimatedSavingsUSD))
			body.WriteString(fmt.Sprintf("  - Risk: %s\n", decision.RiskLevel))
		}
	}

	body.WriteString("\n### ü§ñ AI Review\n\n")
	body.WriteString("This PR will be automatically reviewed by **CodeRabbit**.\n\n")
	body.WriteString("---\n")
	body.WriteString("*Generated by CostGuard - Autonomous Cloud Cost Optimization*")

	return body.String()
}

func buildCommitMessage(actions []types.FixAction, summary types.AIDecisionSummary) string {
	return fmt.Sprintf(
		"perf(costguard): optimize resources (save $%.2f/month)\n\nAI-reviewed optimization with %d actions applied",
		summary.TotalSavingsUSD,
		summary.ActionsToApply,
	)
}

func execGit(args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}
